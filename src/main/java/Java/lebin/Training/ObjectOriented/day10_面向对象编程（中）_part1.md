##本单元目标
	1、继承 √
	2、多态 √
	3、Object类


##继承


###理解

	生活中的继承：子女继承了父母的财产或相貌或才华

	java中的继承：一个类不用自己定义属性或方法，就已经具备了另一个类的属性和方法
	把这种现象称为java中的继承！
	继承其他类的类，称为子类或派生类。
	被继承的类，称为父类或超类或基类


###好处

	1、提高代码的重用性
	2、提高代码的扩展性和维护性
	3、为多态打下了基础


###语法

	使用extends关键字

	class Sub extends Super{


	}

###使用特点
	1、子类到底继承了父类的哪些成员？
		所有的属性和方法，只是私有的不能直接访问，而是通过公共的方法去访问
		注意：子类在访问继承来的成员时，也是需要先去遵循访问权限的限定


	2、子类不能继承父类的构造器，但必须调用父类的构造器

	3、不能滥用继承，子类和父类之间必须满足 is-a的关系
	class 子类 extends 父类{}
	子类 是父类吗？

	class Book extends Animal{}
	Book  是动物吗?

	4、子类可以直接继承几个父类？

	答：一个
	java中支持单继承！

	5、子类的继承不限于直接父类

	6、java中所有的类都直接或间接继承了Object类，也就是Object类为所有类的祖先类


	

###子类调用父类构造器的特点
	1、子类必须调用父类的构造器

	2、子类如果没有显式的调用父类的构造器，则默认调用父类的无参构造器
	   父类中如果没有无参构造器，则子类中必须显式的调用父类的有参构造器，通过super关键字去调用，语法为 super(实参列表);

	3、构造器的调用，不限于直接父类



##super关键字的使用

###理解

	super代表父类的引用，用于访问父类的属性、方法、构造

###语法

	访问父类的属性：super.属性名=值;
	访问父类的方法：super.方法（实参列表）;
	访问父类的构造：super(实参列表);
				注意：必须在子类的构造器的第一句

	注意：在相对子类中，去访问父类的成员


###好处
	1、当子类需要显式调用父类的构造器时，则必须通过super关键字
	2、当子类和父类的成员重名时，为了访问父类的成员，则必须通过super关键字
   		联想：
		当局部变量和当前类的成员变量重名时，可以通过this区分开
		当当前类的成员变量和父类的成员变量重名时，可以通过super区分开


###特点
	1、super的使用不限于直接父类
	2、如果父类和爷爷类中都相同的成员，则默认访问的是父类的成员，遵循就近原则
	3、this(实参列表)和super(实参列表)不能同时出现在构造器中

###this和super的对比


	1.this：代表本类对象，可以访问本类的属性、方法、构造。它的出现主要为了区分成员变量和局部变量，以及调用本类构造器。
	通过this访问成员时，先从本类中查找，如果找不到再从直接父类找，如果还找不到，继续往上追溯找间接父类，直到找到为止！
	
	2.super：代表父类引用，可以访问父类的属性、方法、构造。它的出现主要为了区分本类和父类的成员，以及调用父类构造器。
	通过super访问成员时，先从直接父类找，如果还找不到，继续往上追溯找间接父类，直到找到为止！

	


##方法的重写

###理解
	子类对从父类继承过来的方法进行改造，这种现象称为方法的重写或覆写或覆盖


###要求

	方法名和参数列表完全相同，返回类型相同或子类重写方法的返回类型为子类类型，修饰符相同或权限更大

###【面试题】重写和重载的对比
		发生范围		方法名		参数列表		返回类型			修饰符


重载		同一个类中	必须相同		必须不同		无要求			无要求

重写		父子类中		必须相同		必须相同		相同或为子类型	相同或权限更大
		


##多态

###理解
	多态：一种事物有多种表现形式。面向对象的最后一个特征，继承和封装都是为多态打基础！
	
生活中的多态：

	打招呼：
	中国人：你好
	英国人：hello
	日本人：拷逆七娃
	韩国人：阿娘哈赛you
	泰国人：萨瓦迪卡


参加同学聚会：

	某人：开着法拉利
	某人：开着奥拓
	某人：骑着摩拜
	

倚天屠龙记

	六大门派围攻光明顶
	少林：易筋经
	武当：太极
	峨眉：绝情剑法
	崆峒：七伤拳
	昆仑：
	青城：

	组织者：发出号令：大家开始抄起家伙围攻吧！


###多态的体现

	1、方法的多态性
	方法的重写和重载

	2、对象的多态性
	对象的转型上！
	Person p = new Student();
	


###引用类型之间的类型转换(对象的多态)

前提：父子关系

一、向上转型

本质：父类的引用指向了子类的对象

语法：

	父类类型 	引用名 = new  子类类型();

特点：

	编译看左边，运行看右边
	可以调用父类类型中的所有成员，不能调用子类类型中特有成员；最终运行效果看子类的具体实现！


二、向下转型

语法：

	子类类型 	引用名 =  （子类类型）父类引用;
特点：

	①只能强转父类的引用，不能强转父类的对象
	②要求父类的引用必须指向的是当前目标类型的对象
	③可以调用子类类型中所有的成员



	补充：属性没有重写之说！属性的值看编译类型




###多态的应用

	1、多态数组
	数组的元素类型允许是子类类型，相当于可以容纳更多的元素
	2、多态参数
	实参的类型允许是子类类型，相当于提高了代码的通用性和扩展性



##Object类

###学习类的步骤
	1、看包
	2、说明【了解】
	3、看构造器
	4、学习里面的属性和方法
###1.包
	java.lang包  ***（这个LANG指的是LANGUAGE）***
	注意：该包是系统默认导入的，不用手动导包

###2.类的说明
	Object类是所有类的超类，所有对象都具有Object类的方法

###3.构造器

	new Object();
	注意：基本上不会创建Object对象


###4.方法 ★

一、equals方法

【面试题】==和equals的对比

 
  == 可以判断基本类型或引用类型，不管判断什么类型的元素，都要求 左右两边的类型一致或兼容，否则编译报错
  		如果判断的是基本类型，则判断的是值是否相等。示例：100==‘d’ true	  1.0==1 true
  		如果判断的是引用类型，则判断的是地址是否相等。示例：person1==person2    string1 == string2
  
  
 equals 只能判断引用类型,可以判断任何引用类型，编译不会报错
  		Object类的equals：判断的就是地址是否相等！往往子类需要重写equals方法，实现判断内容是否相等。比如：String、Integer类等都重写了equals方法

 *## 如何重写equals方法 ##*

		public boolean equals(Object obj){//this：person1  obj:person4
		//步骤1：两个对象的地址一样（提高效率）
		if(this==obj)
			return true;
		//步骤2：判断对象的类型
		if(!(obj instanceof Person)){//如果传入的obj不是Person类型，则直接返回
			return false;
		}
		//步骤3：对象的向下转型
		Person p = (Person) obj;//向下转型
		//步骤4：判断内容是否相等
		return this.name.equals(p.name)&&this.age==p.age;



二、toString方法
1、功能

	返回对象的字符串形式。默认返回的是：全类名+@+哈希值的十六进制
	public String toString(){

		return getClass().getName()+"@"+Integer.toHexString(hashCode());
	}

	子类往往重写该方法

2、如何重写toString方法？

	public String toString(){
		return 属性信息；

	}
3、好处：

	打印方法和拼接字符串时，会自动调用对象的toString方法，提高代码的简洁性！


三、hashCode方法

1、功能

	返回对象的哈希值（以整数形式返回对象的一个特殊值），
	提高集合中查找元素相等的效率！

2、特点
	对象的哈希值 约等于 对象的地址号

	
3、推论
	如果哈希值不一样，则两个对象肯定不一样！


	
四、finalize方法


 自动垃圾回收机制

 原理：当应用已启动，实际上相当于开起了 主线程main和垃圾回收器线程
 垃圾回收器将默默检测是否有需要回收的对象，一旦有了，则需要回收该对象以释放空间供其他有用对象使用，该对象被回收时同时调用finalize方法
 
	 1、回收哪些对象？
	 答：无用对象（没有任何引用指向的对象）
	 
	 2、回收的时机？
	 答：不确定的
	 
	 3、如何加速垃圾回收器的回收？
	 
	 答：唤醒垃圾回收器
	 System.gc();
	 
	 4、finalize方法什么时候被调用？
	 只要被回收，肯定被调用