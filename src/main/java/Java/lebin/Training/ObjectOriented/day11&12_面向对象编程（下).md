##本单元目标
	1、static关键字  ★
	2、final关键字 √
	3、单例设计模式 ★【面试题】
	4、初始化块  【面试题】
	5、抽象类  ★【应用】
	6、接口 ★【应用】



##一、static关键字

###理解

	static看做一种修饰符，可以用于修饰类的成员（**属性、方法**、内部类、初始化块），但不能修饰构造器和局部变量
	
	使用static修饰的成员，称为静态成员
		用static修饰的属性，称为静态属性
		用static修饰的方法，称为静态方法
	
	没有使用static修饰的成员，称为普通成员或实例成员
		没有使用static修饰的属性，称为普通属性或实例变量
		没有使用static修饰的方法，称为普通方法或实例方法




###静态成员的特点

	1、静态成员随着类的加载而加载
	2、静态成员都是存储方法区（静态域）
	3、静态成员整个内存中只有一份
	4、静态成员都是和对象无关的成员，所以可以直接通过类名调用
	5、静态成员（除了静态属性），里面都是可以直接调用其他静态成员，不能直接调用普通成员

##单例设计模式
###什么时候使用单例模式：
	当一个项目中 要求某类只有一个对象时！
###应用场景：
	1、项目中只想多次调用该对象的方法时，为了提高效率
	2、如果创建多个对象，会导致逻辑错误时


###步骤：

	  1、构造器私有化
	  2、本类内部创建对象
	  3、提供public static方法，暴露该对象
	 
饿汉式和懒汉式的差异：

  
  1、创建对象的时机不同！

  2、应用场合不同

  如果仅仅考虑效率问题，可以使用懒汉式
  如果考虑线程安全问题，可以使用饿汉式
  
  
  经典案例：Runtime类就使用了饿汉式单例设计模式
  
  【面试题】自己编写懒汉式代码！

##三、final关键字

###理解

	final关键字属于一种修饰符，可以用于修饰类、属性、方法、局部变量

###特点

1、修饰类

 如果用final修饰类，则该类变成了“太监类”，不能被继承
 代表类：String、Integer等

2、修饰方法

  如果用final修饰方法，则该方法不能被重写，但可以被继承

3、修饰属性和局部变量

  ①如果修饰变量（属性和局部），该变量就变成了常量，一旦赋值，将不能更改！ ★

  ②修饰属性，需要注意以下事项：

  		a、命名时最好遵循见名知义,且纯大写，提高代码的阅读性！
  		b、一般来讲static和final往往一起搭配修饰常量属性
  			两个修饰符的意思不冲突
  			调用比较方便
  			jvm对使用这两个修饰符搭配的属性，内部进行了优化
 
  		c、常量属性在声明时或构造器时必须初始化
  
  ③基本类型的值，一旦更改，则就是更改值，不允许！
   引用类型的对象，如果更改属性值是允许的，但不能更改地址号！


	
##四、初始化块

###理解

初始化块又称为代码块。属于类中的第四大成员。本质上是一个方法，它也有方法体，但没有方法名，没有参数，没有返回，而且也不是通过对象或类名显式调用，而是通过隐式调用


###语法

	[修饰符]{

		方法体
	}

	注意：
	①修饰符只能是static，使用static修饰的初始化块称为静态初始化块
						没有使用static修饰的初始化块称为普通初始化块
	//静态初始化块
	static{

	}
	//普通初始化块
	{

	}
	②方法体中可以为任意逻辑语句，包含输入、输出、变量、运算等


###好处

	1、和构造器很像，都是用于初始化信息

	2、当多个构造器中有重复的语句，可以将这些重复的语句往上提取到初始化块中，提高代码的重用性


###特点

	1、调用时机
	  静态初始化块的调用时机：加载类
	  普通初始化块的调用时机：创建对象

	2、调用次数
	静态初始化块只会调用一次，随着类的加载而加载，（类只加载一次）
	  普通初始化块可以调用多次，随着对象的创建而加载

	3、执行次序（初始化块-静态、普通之间的对比）
	一个类中可以有多个静态初始化块和多个普通初始化块
	静态初始化块的执行要早于普通初始化块
	同一个类型的初始化块的执行顺序取决于定义的先后顺序！
	
	4、执行次序（初始化块、属性、构造器和静态、普通两个维度的对比）
	一个类中如果有：静态初始化块、普通初始化块、普通属性初始化、静态属性初始化、构造器
	执行顺序：
	静态初始化块|静态属性初始化>普通初始化块|普通属性初始化>构造器
	
	5、有父子类
	执行顺序：
	爷爷类的静态初始化块|静态属性初始化>
	父类静态初始化块|静态属性初始化>
	子类静态初始化块|静态属性初始化>
	爷爷类普通初始化块|普通属性初始化>构造器>
	父类普通初始化块|普通属性初始化>构造器>
	子类普通初始化块|普通属性初始化>构造器
	
	6、静态初始化块中遵循静态成员的特点，只能直接访问静态成员！

##五、抽象类和抽象方法


###abstract关键字的理解

	abstract关键字属于一种修饰符，用于修饰类和方法，但不能修饰属性、局部变量、构造器

	使用abstract修饰的类，称为抽象类
	使用abstract修饰方法，称为抽象方法



###抽象类的理解和特点

	理解：往往将里面包含抽象方法的父类，设计成抽象类
	1、父类
	2、里面有一些不好描述的行为


语法：
	 [访问修饰符] abstract class 类名{}
特点：

	 * ①抽象类不能创建本类的对象
	 * ②抽象类有构造器，供子类调用
	 * ③抽象类中可以有哪些成员？
	 * 任意成员（包含普通成员和抽象方法）
	 * ④抽象类中也可以没有抽象方法
	 * ⑤不能使用final修饰抽象类，因为和继承的意义相悖
	 * 
	 * ⑥抽象类的扩展
	 * 普通子类 继承抽象类要求必须实现里面所有抽象方法
	 * 抽象子类继承抽象类不用实现里面的抽象方法
 
###抽象方法的理解和特点
 
 语法：
  
  	【访问修饰符】 abstract 返回类型 方法名(参数列表);
  
特点：
  
	 	①没有方法体，只有方法签名，使用分号结尾
	  
	  	②修饰符不能是final、static或private中的任何一个
	  因为这些修饰符和重写的意义相悖
	  
	  	③抽象方法只能出现在抽象类或接口中！



##六、接口


###理解

	里面有抽象方法的类，称为抽象类【半成品】
	里面全是抽象方法的抽象类，称为接口。

	生活的案例：

	张三丰：接口

	宋远桥：抽象类
		太极拳：出神入化
		太极剑：差一点
		

	宋青书：具体类

	接口——抽象类——具体类

	一流企业卖标准，二流企业卖服务，三流企业卖产品


###好处


	1、避免了java中单继承的局限性
	2、接口的实现更加灵活，不再是is-a的关系
	而是like-a的关系

	3、接口提高了类和类之间的解耦性，减少了类的依赖性

	



###抽象类和接口的对比


1、定义关键字

抽象类：abstract class 

接口： interface 


2、是否有构造器       

抽象类：有          
接口：没有       


3、是否可以创建本类对象   

抽象类：不能            
接口：不能  

4、是否可以有普通成员

抽象类：可以有           
接口：不可以，里面只能是静态常量和抽象方法（jdk8之前）


5、关于里面的抽象方法问题            
抽象类：里面的抽象方法不能使用private、final、static修饰，除了这些都可以，但修饰符不可以省略

接口：里面的抽象方法只能使用 public abstract修饰，而且可以省略

6、继承性     
抽象类：单继承         
接口：多继承多实现          

7、应用          

抽象类和接口都可以应用在多态上！        