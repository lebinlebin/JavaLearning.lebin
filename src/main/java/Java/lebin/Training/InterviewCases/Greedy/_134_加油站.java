package Java.lebin.Training.InterviewCases.Greedy;

/**
 * 134. 加油站
 * 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
 * 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
 * 示例 1:
 * 输入:
 * gas  = [1,2,3,4,5]
 * cost = [3,4,5,1,2]
 * 输出: 3
 * 解释:
 * 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
 * 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
 * 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
 * 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
 * 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
 * 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
 * 因此，3 可为起始索引。
 * */
//贪⼼的思路，
// 局部最优：当前可移动距离尽可能多⾛，如果还没到终点，步数再加⼀。
// 整体最优：⼀步尽可能多⾛，从⽽达到最⼩步数。

//时间复杂度：O(n)
//空间复杂度：O(1)
public class _134_加油站 {
	public int canCompleteCircuit(int[] gas, int[] cost) {
		int curSum = 0;
		int totalSum = 0;
		int start = 0;
		for (int i = 0; i < gas.length; i++) {
			curSum += gas[i] - cost[i];
			totalSum += gas[i] - cost[i];
			//把所有的剩余油量都加在一起，如果totalSum<0,说明我们从任何一个位置开始跑都不可能跑完一圈。
			// 因为整体消耗都是一个负数，直接reture -1；这里只是放到了一个for循环里面。
			if (curSum < 0) { // 当前累加rest[i]和 curSum⼀旦⼩于0 说明i之前的位置都不适合作为起始位置。因此i之前的位置全部可以排除掉
				start = i + 1; // 起始位置更新为i+1；
				curSum = 0; // curSum从0开始
			}
		}
		//问题不是要走一圈么，这里感觉只走到了数组的结尾呢？因为 curSum⼀旦⼩于0，说明i之前的位置都不适合作为起始位置
		if (totalSum < 0) return -1; // 说明怎么⾛都不可能跑⼀圈了
		return start;
	}
}
