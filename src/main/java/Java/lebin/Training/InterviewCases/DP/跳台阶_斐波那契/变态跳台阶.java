package Java.lebin.Training.InterviewCases.DP.跳台阶_斐波那契;
/*
#70. 爬楼梯（进阶版）
卡码网：57. 爬楼梯(opens new window)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
输入描述：输入共一行，包含两个正整数，分别表示n, m
输出描述：输出一个整数，表示爬到楼顶的方法数。

输入示例：3 2
输出示例：3

提示：
当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。
此时你有三种方法可以爬到楼顶。
1 阶 + 1 阶 + 1 阶段
1 阶 + 2 阶
2 阶 + 1 阶
#
 */
public class 变态跳台阶 {
    /*
	题目描述
	一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

	解题思路
	f(1) = 1
	f(2) = f(2-1) + f(2-2)
	f(3) = f(3-1) + f(3-2) + f(3-3)
	...
	f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)

	要跳到第n级，
	第一种方法是：最后一步只跳一级，则前面需要跳n-1级，这n-1 级的跳法有f(n-1)种；
	第二种方法是：最后一步只跳两级，则前面需要跳 n-2级，则 前面 n-2 级的跳法有f(n-2) 种；
	以此类推，直到最后，一次跳 n 级，则此时只有一种跳法，即最后的+1。

	f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n)
	f(n-1) = f(n-2)+...+f(n-(n-1)) + f(n-n)
	===> f(n) = 2 * f(n-1)
	最后可以得到
	f(n) = 1, (n=0)
	f(n) = 1, (n=1)
	f(n) = 2*f(n-1),(n>=2)
	 */
    public int JumpFloorII(int target) {
        if (target <= 0)
            return 0;
        if (target == 1 || target == 2)
            return target;
        else
            return 2 * JumpFloorII(target - 1);
    }
    /*
    这次改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？
这又有难度了，这其实是一个完全背包问题。
1阶，2阶，.... m阶就是物品，楼顶就是背包。
每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。
问跳到楼顶有几种方法其实就是问装满背包有几种方法。
此时大家应该发现这就是一个完全背包问题了！

确定dp数组以及下标的含义
dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。

确定递推公式
在动态规划：494.目标和 (opens new window)、 动态规划：518.零钱兑换II (opens new window)、动态规划：377. 组合总和 Ⅳ (opens new window)中我们都讲过了，求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];

本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]

那么递推公式为：dp[i] += dp[i - j]

dp数组如何初始化
既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。

下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果

确定遍历顺序
这是背包里求排列问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！

所以需将target放在外循环，将nums放在内循环。

每一步可以走多次，这是完全背包，内循环需要从前向后遍历。

举例来推导dp数组

     */

    //    时间复杂度: O(n * m)
//    空间复杂度: O(n)
    //代码中m表示最多可以爬m个台阶，代码中把m改成2就是 力扣：70.爬楼梯的解题思路。
    //这次改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？
    public int JumpFloorII2(int n, int m) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历物品
            for (int j = 1; j <= m; j++) { // 遍历背包
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
}
