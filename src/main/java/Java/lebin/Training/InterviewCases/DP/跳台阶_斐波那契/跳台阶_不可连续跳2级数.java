package Java.lebin.Training.InterviewCases.DP.跳台阶_斐波那契;

import java.util.Arrays;

/*
题目描述
题目1:有一个 n 阶的楼梯，你从最下面往上跳，每次可以跳1阶或2阶，有多少种方法可以跳到楼顶？
思路:
这个基础版很简单，对于第 n 阶，你只有两种方式跳上去：从 n-1 阶跳1阶跳上去; 从 n-2 阶跳2阶跳上去;
可以得到递推式：f(n)=f(n-1)+f(n-2)
----------------------------------------------------------------------------------------------------
题目2:题目基本一样，有一个 n 阶的楼梯，你从最下面往上跳，每次可以跳1阶或2阶，但是不能连续跳两次2阶，有多少种方法可以跳到楼顶？
思路：
利用之前基础版的思路，对于第 n 阶，你只有两种方式跳上去：
1. 从 n-1 阶跳1阶跳上去
2. 从 n-2 阶跳2阶跳上去（同时 n-2 阶必须是跳 1 阶跳上去的）
这里多了一个限制：从 n-2 阶跳 2 阶跳到 n 阶的 n-2 阶状态必须是从 n-3 阶跳1阶跳到 n-2 阶的。
所以，这里动态规划不仅要保存跳到第 i 阶的所有方法数，还要保存最后一步通过跳 1 阶跳到第 i 阶的方法数。
这里用 f(n) 表示跳到第 n 阶的总方法数，用 g(n) 表示最后一步跳一阶跳到第 n 阶的方法数，这样就得到递推式：
f(n)=f(n-1)+g(n-2)// 从 n-1 阶跳1阶跳上去 的 跳法种数  +  从n-2级跳2级跳上去的方法种数
g(n)=f(n-1)//从 n-1 阶跳1阶跳上去 的 跳法种数 就是g(n)
f(n) = f(n-1) + f(n-3)
---------------------------------------------------------------------------------------------------
题目3:题目基本一样，有一个 n 阶的楼梯，你从最下面往上跳，每次可以跳1阶或2阶或3阶，但是不能连续跳两次3阶，有多少种方法可以跳到楼顶？
f(n)=f(n-1)+f(n-2)+g(n-3)// 从 n-1 阶跳1阶跳上去 的 跳法种数  + 从 n-2 阶跳2阶跳上去 的 跳法种数 + 从n-3级跳3级跳上去的方法种数（同时 n-3 阶必须是跳 1 阶或者2级跳上去的）
g(n)=f(n-1)+f(n-2) //从 n-1 阶跳1阶或者跳2阶跳上去 的 跳法种数 就是g(n)
f(n) = f(n-1)+f(n-2)+ f(n-4)+f(n-5)
----------------------------------------------------------------------------------------------------
题目4: 跳台阶，不可连续跳相同级数
一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级，也可以跳3级，但是不能连续跳相同的级数。例如，第一次跳了1级，第二次只能跳2级或者3级。求总共有多少总跳法。
思路:
dp[i][j]表示跳到第i阶，最后一步跳了j级。该状态依赖于前面的状态，前面状态的最后一步起跳不能为j。
dp[4][1]表示跳到第4阶，最后一步跳了1级，因为从第3阶跳到第4阶需要跳1阶，那么到达第3阶的时候，最后一步就只能为2，或者3。
dp[4][2]表示跳到第4阶，最后一步跳了2级，因为从第2阶跳到第4阶需要跳2阶，那么到达第2阶的时候，最后一步就只能为1，或者3。
dp[4][3]表示跳到第4阶，最后一步跳了3级，因为从第1阶跳到第4阶需要跳3阶，那么到达第1阶的时候，最后一步就只能为1，或者2。
----------------------------------------------------------------------------------------------------
题目5: 一个台阶共有n级，如果一次可以跳1级，也可以跳2级，……，也可以跳n级，共有多少种跳法？

----------------------------------------------------------------------------------------------------
题目6:⼀步⼀个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的⽅法可以爬到楼顶呢？
1阶，2阶，.... m阶就是物品，楼顶就是背包。
每⼀阶可以重复使⽤，例如跳了1阶，还可以继续跳1阶。
问跳到楼顶有⼏种⽅法其实就是问装满背包有⼏种⽅法。
此时⼤家应该发现这就是⼀个完全背包问题了！
1.  dp定义
    dp[i]：爬到有i个台阶的楼顶，有dp[i]种⽅法。
2. 递推公式:
    dp[i]有⼏种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]
    递推公式为：dp[i] += dp[i - j]
3.  dp数组如何初始化
    既然递归公式是 dp[i] += dp[i - j]，那么dp[0] ⼀定为1，dp[0]是递归中⼀切数值的基础所在，如果dp[0] 是0的话，其他数值都是0了。
    下标⾮0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果
4.  确定遍历顺序
    这是背包⾥求排列问题，即：1、2 步    和 2、1 步都是上三个台阶，但是这两种⽅法不⼀样！ 所以需将target放在外循环，将nums放在内循环。
    每⼀步可以⾛多次，这是完全背包，内循环需要从前向后遍历。

 */
public class 跳台阶_不可连续跳2级数 {
    //问题1:基础版本跳台阶
    public static int jumpStairs(int n) {
        if (n <= 3)
            return n;
        //
        int[] dp = new int[n];
        for (int i = 0; i < n; i++) {
            if (i <= 2) {
                dp[i] = i+1;
            } else {
                dp[i] = dp[i-1] + dp[i-2];
            }
        }
        System.out.println("dp："+ Arrays.toString(dp));
        return dp[dp.length-1];
    }

    //问题二:不能连续跳两次2阶跳台阶
    public static int modifiedJumpStairs2(int n) {
        if (n <= 3)
            return n;
        // dp数组的第一个维度表示: 从 n-1 阶跳1阶跳上去 的 跳法种数
        // dp数组的第二个维度表示: 从 n-2 阶跳2阶跳上去 的 跳法种数
        int[][] dp = new int[n][2];
        //斐波那契数列： 1、1、2、3、5、8、13、21、34 截取 1、2、3、5、8、13、21、34
        /*
        初始值还是需要通过递推公式来填写。
        f(n)=f(n-1)+g(n-2)// 从 n-1 阶跳1阶跳上去 的 跳法种数  +  从n-2级跳2级跳上去的方法种数
        g(n)=f(n-1)//从 n-1 阶跳1阶跳上去 的 跳法种数 就是g(n)
        f(n) = f(n-1) + f(n-3)
        f(0) = 1
        f(1) = f(0)+f(-2) = 1 --->dp[0][0]
        f(2) = f(1)+f(-1) = 1 --->dp[1][0]
        f(3) = f(2)+f(0) = 1 + 1 = 2 --->dp[2][0]
        f(4) = f(3)+f(1) = 2 + 1 = 3 --->dp[3][0]
        f(5) = f(4)+f(2) = 3 + 1 = 4 --->dp[4][0]
        f(6) = f(5)+f(3) = 4 + 2 = 6 --->dp[5][0]
        -------
        g(0) = f(-1) = 1
        g(1) = f(0) = 1
        g(2) = f(1) = 1 --->dp[0][1]
        g(3) = f(2) = 1 --->dp[1][1]
        g(4) = f(3)= 2  --->dp[2][1]
        g(5) = f(4) = 3  --->dp[3][1]
        g(6) = f(5) = 4  --->dp[4][1]
        */
        dp[0][0] = 1;//第一个维度 1 默认不跳跃，原地不动(跳0级)也是一种方法
        dp[0][1] = 1; //第二个维度 1  原地不动(跳0级) 算一种方法

        dp[1][0] = 2;//从0跳一级上去，然后原地不动(跳0级) + 原地不动(跳0级)，从0级跳一级上去
        dp[1][1] = 1;//原地不动(跳0级)，没法跳两级

        dp[2][0] = 3;// 跳1级+跳1级+跳0级(包含跳1级+跳1级的情况); 跳0级+跳1级+跳1级 ； 跳1级+跳0级+跳1级;
        dp[2][1] = 2;//跳0级+跳2级;跳2级+跳0级

        for (int i = 3; i < n; i++) {
            dp[i][0] = dp[i-1][0] + dp[i-2][1];
            dp[i][1] = dp[i-1][0];
        }
        System.out.println("dp："+ Arrays.deepToString(dp));
        return dp[dp.length-1][0];
    }
    //问题二:不能连续跳两次2阶跳台阶 递推公式简化版本
    //f(n)=f(n-1)+g(n-2)// 从 n-1 阶跳1阶跳上去 的 跳法种数  +  从n-2级跳2级跳上去的方法种数
    //g(n)=f(n-1)//从 n-1 阶跳1阶跳上去 的 跳法种数 就是g(n)
    //f(n) = f(n-1) + f(n-3)
    public static int modifiedJumpStairs2_2(int n) {
        if (n <= 3)
            return n;
        int[] dp = new int[n];
        //dp[0]=1;dp[1]=2;dp[2]=3;
        for (int i = 0; i < n; i++) {
            if (i <= 2) {
                dp[i] = i+1;
            } else {
                dp[i] = dp[i-1] + dp[i-3];//初始值至少计算到i=2
            }
        }
        System.out.println("dp:"+ Arrays.toString(dp));
        return dp[dp.length-1];
    }
    //问题3 : 跳台阶，每次可以跳1阶或2阶或3阶，但是不能连续跳两次3阶，
//    f(n)=f(n-1)+f(n-2)+g(n-3)// 从 n-1 阶跳1阶跳上去 的 跳法种数  + 从 n-2 阶跳2阶跳上去 的 跳法种数 + 从n-3级跳3级跳上去的方法种数（同时 n-3 阶必须是跳 1 阶或者2级跳上去的）
//    g(n)=f(n-1)+f(n-2) //从 n-1 阶跳1阶或者跳2阶跳上去 的 跳法种数 就是g(n)
//    f(n) = f(n-1)+f(n-2)+ f(n-4)+f(n-5)
    public static int modifiedJumpStairs3(int n) {
        if (n <= 3)
            return n;
        // dp数组的第一个维度表示: 从 n-1 阶跳1阶跳上去 的 跳法种数
        // dp数组的第二个维度表示: 从 n-2 阶跳2阶跳上去 的 跳法种数
        // dp数组的第三个维度表示: 从 n-3 阶跳3阶跳上去 的 跳法种数
        int[][] dp = new int[n][2];

        dp[0][0] = 1;//第一个维度 1 默认不跳跃，原地不动(跳0级)也是一种方法
        dp[0][1] = 1; //第二个维度 1  原地不动(跳0级) 算一种方法

        dp[1][0] = 2;//从0跳一级上去，然后原地不动(跳0级) + 原地不动(跳0级)，从0级跳一级上去
        dp[1][1] = 1;//原地不动(跳0级)，没法跳两级

        dp[2][0] = 3;// 跳1级+跳1级+跳0级(包含跳1级+跳1级的情况); 跳0级+跳1级+跳1级 ； 跳1级+跳0级+跳1级;
        dp[2][1] = 2;//跳0级+跳2级;跳2级+跳0级

        for (int i = 3; i < n; i++) {
            dp[i][0] = dp[i-1][0] + dp[i-2][1];
            dp[i][1] = dp[i-1][0];
        }
        return dp[dp.length-1][0];
    }

    public static int modifiedJumpStairs32(int n) {
    /*
    f(n)=f(n-1)+f(n-2)+g(n-3)// 从 n-1 阶跳1阶跳上去 的 跳法种数  + 从 n-2 阶跳2阶跳上去 的 跳法种数 + 从n-3级跳3级跳上去的方法种数（同时 n-3 阶必须是跳 1 阶或者2级跳上去的）
    g(n)=f(n-1)+f(n-2) //从 n-1 阶跳1阶或者跳2阶跳上去 的 跳法种数 就是g(n)
    f(n) = f(n-1)+f(n-2)+ f(n-4)+f(n-5)
    ----------------------------------
    f(0) = 1
    f(1) = f(0) = 1
    f(2) = f(1) + f(0) = 1 + 1 = 2
    f(3) = f(2) + f(1) = 2 + 1 = 3
    f(4) = f(3) + f(2)  + f(0) = 3 + 2 + 1 = 6
    f(5) = f(4) + f(3)  + f(1) + f(0) = 6 + 3 + 1 + 1 = 11
    f(6) = f(5) + f(4)  + f(2) + f(2) = 11 + 6 + 2 + 1 = 20
     */
        if (n <= 3)
            return n;
        int[] dp = new int[n];
        dp[0]=1;
        dp[1]=2;
        dp[2]=3;
        dp[3]=6;
        dp[4]=11;
        for (int i = 5; i < n; i++) {
            dp[i] = dp[i-1] + dp[i-2] + dp[i-4] + dp[i-5];//初始值至少计算到i=4
        }
        System.out.println("dp:"+ Arrays.toString(dp));
        return dp[dp.length-1];
    }


    //问题4 : 跳台阶，不可连续跳相同级数
    /*
    题目4: 跳台阶，不可连续跳相同级数
    一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级，也可以跳3级，但是不能连续跳相同的级数。例如，第一次跳了1级，
    第二次只能跳2级或者3级。求总共有多少总跳法。
    思路:
    dp[i][j]表示跳到第i阶，最后一步跳了j级。该状态依赖于前面的状态，前面状态的最后一步起跳不能为j。
    dp[4][1]表示跳到第4阶，最后一步跳了1级，因为从第3阶跳到第4阶需要跳1阶，那么到达第3阶的时候，最后一步就只能为2，或者3。
    dp[4][2]表示跳到第4阶，最后一步跳了2级，因为从第2阶跳到第4阶需要跳2阶，那么到达第2阶的时候，最后一步就只能为1，或者3。
    dp[4][3]表示跳到第4阶，最后一步跳了3级，因为从第1阶跳到第4阶需要跳3阶，那么到达第1阶的时候，最后一步就只能为1，或者2。
     */
    public static int jump(int n) {
        int[][] dp = new int[n + 1][4]; // dp[i][j] 跳到第 i 阶，最后一步跳了 j 级
        dp[1][1] = 1;//跳到第1级，最后一步跳了1级，有一种方法
        dp[2][2] = 1;//跳到第2级，最后一步跳了2级，有一种方法
        dp[3][1] = 1;//跳到第三级，最后一步跳了1级，那么在第二级台阶，可以由跳2和3级的选择，这里只能选择跳2级，有一种方法
        dp[3][2] = 1;//跳到第三级，最后一步跳了2级，那么在第一级台阶可以跳1和3级的选择，这里只能选择跳一级，有一种方法
        dp[3][3] = 1;//跳到第三级，最后一步跳了3级，只有一种方法
        for (int i = 4; i <= n; i++) {
            dp[i][1] = dp[i-1][2]+dp[i-1][3];
            dp[i][2] = dp[i-2][1]+dp[i-2][3];
            dp[i][3] = dp[i-3][1]+dp[i-3][2];
        }
        return dp[n][1] + dp[n][2] + dp[n][3];
    }



    /*
    题目5: 一个台阶共有n级，如果一次可以跳1级，也可以跳2级，……，也可以跳n级，共有多少种跳法？
    解题思路
    f(1) = 1
    f(2) = f(2-1) + f(2-2)
    f(3) = f(3-1) + f(3-2) + f(3-3)
    ...
    f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)

    要跳到第n级，
    第一种方法是：最后一步只跳一级，则前面需要跳n-1级，这n-1 级的跳法有f(n-1)种；
    第二种方法是：最后一步只跳两级，则前面需要跳 n-2级，则 前面 n-2 级的跳法有f(n-2) 种；
    以此类推，直到最后，一次跳 n 级，则此时只有一种跳法，即最后的+1。

    f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n)
    f(n-1) = f(n-2)+...+f(n-(n-1)) + f(n-n)
    ===> f(n) = 2 * f(n-1)
    最后可以得到
    f(n) = 1, (n=0)
    f(n) = 1, (n=1)
    f(n) = 2*f(n-1),(n>=2)
     */
    public static int JumpFloorII(int target) {
        if (target <= 0)
            return 0;
        if (target == 1 || target == 2)
            return target;
        else
            return 2 * JumpFloorII(target - 1);
    }

    //题目6： ⼀步⼀个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的⽅法可以爬到楼顶呢？
    //    时间复杂度: O(n * m)
    //    空间复杂度: O(n)
    //    代码中m表示最多可以爬m个台阶
    public static int climbStairs6(int n, int m) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println(jumpStairs(n));
        System.out.println("----------------------------------");
        System.out.println(modifiedJumpStairs2_2(n));
        System.out.println("----------------------------------");
        System.out.println(modifiedJumpStairs2(n));
        System.out.println("----------------------------------");
        System.out.println(modifiedJumpStairs32(n));

    }
}
