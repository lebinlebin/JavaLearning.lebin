package Java.lebin.Training.InterviewCases.DP.跳台阶_斐波那契;
/*
746. 使用最小花费爬楼梯
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。
示例 1：
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15
 */
/*
1. dp定义
    dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。
2. 递推公式
    可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。
    dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。
    dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。
    所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
3. 初始化
    最终都是dp[0]dp[1]推出。
    题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。
    初始化 dp[0] = 0，dp[1] = 0;
4. 确定遍历顺序
    从前到后遍历
    因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。
 */
public class _746_使用最小花费爬楼梯 {
    //时间复杂度：O(n)
    //空间复杂度：O(1)
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int[] dp = new int[len + 1];//dp[i] 表示达到下标 i 的最小花费。
        // 从下标为 0 或下标为 1 的台阶开始，因此支付费用为0
        dp[0] = 0;
        dp[1] = 0;
        // 计算到达每一层台阶的最小费用
        //当 2≤i≤n 时，可以从下标 i−1 使用 cost[i−1] 的花费达到下标 i，或者从下标 i−2 使用 cost[i−2] 的花费达到下标 i。
        // 为了使总花费最小，dp[i]应取上述两项的最小值，
        for (int i = 2; i <= len; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[len];
    }
}
