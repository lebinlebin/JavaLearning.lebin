package Java.lebin.Training.InterviewCases.DP.背包问题;

import java.util.Arrays;

/**
 * 518. 零钱兑换 II
 * 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
 * 示例 1:
 * 输入: amount = 5, coins = [1, 2, 5]
 * 输出: 4
 * 解释: 有四种方式可以凑成总金额:
 * 5=5
 * 5=2+2+1
 * 5=2+1+1+1
 * 5=1+1+1+1+1
 */
/*
这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。
但本题和纯完全背包不一样，纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！
322是求可以凑成总金额所需的最少的硬币个数。
本题518是计算可以凑成总金额的硬币组合数。
 */
//-----------------------------------------------------------
/*
注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？
例如示例一：
5 = 2 + 2 + 1
5 = 2 + 1 + 2
这是一种组合，都是 2 2 1。
如果问的是排列数，那么上面就是两种排列了。
组合不强调元素之间的顺序，排列强调元素之间的顺序。
 */
//-----------------------------------------------------------
/*
1. dp定义
	dp[j]：凑成总金额j的货币组合数为dp[j]
2. 递推公式
	dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。
	所以递推公式：dp[j] += dp[j - coins[i]];
3. 初始化
	首先dp[0]一定要为1， 凑成总金额0的货币组合数为1。
4. 遍历顺序
	外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）
	这种遍历顺序中dp[j]里计算的是组合数！
	交换遍历顺序的话
	此时dp[j]里算出来的就是排列数！
 */
//时间复杂度: O(mn)，其中 m 是amount，n 是 coins 的长度
//空间复杂度: O(m)
public class _518_零钱兑换2_完全背包问题 {
	public int change(int amount, int[] coins) {
		//递推表达式
		int[] dp = new int[amount + 1];
		//初始化dp数组，表示金额为0时只有一种情况，也就是什么都不装
		dp[0] = 1;
		for (int i = 0; i < coins.length; i++) {
			for (int j = coins[i]; j <= amount; j++) {
				dp[j] += dp[j - coins[i]];
			}
		}
		return dp[amount];
	}
}
