package Java.lebin.Training.InterviewCases.DP;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/*
给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，
从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。
如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
示例 1：
输入：k = 1, n = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
如果它没碎，那么肯定能得出 f = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
示例 2：
输入：k = 2, n = 6
输出：3
 */
public class _887_鸡蛋掉落 {
/*
时间复杂度：O(knlogn)。我们需要计算 O(kn)个状态，每个状态计算时需要 O(logn) 的时间进行二分查找。
空间复杂度：O(kn)。我们需要 O(kn) 的空间存储每个状态的解。
 */
public int superEggDrop(int k, int n) {
        /*
        dp五部曲:
        1.状态定义:dp[i][j]表示楼层数为i(注意是楼层数),鸡蛋数为j时确定f的最少操作次数
        2.状态转移:dp[i][j]=min<1,i>(max(dp[k-1][j-1],dp[i-k][j])+1),其中外层min的k∈[1,i]
            其中dp[k-1][j-1]为鸡蛋从i楼扔下碎了:那么f只可能是[1,k-1],鸡蛋数-1
                dp[i-k][j]为鸡蛋从i楼扔下没碎:那么f只可能是[k+1,i],鸡蛋数不变
                两者中取较大的值,这是鸡蛋碎与不碎的最坏情况下转移过来的dp[i][j]
                前一个状态+1就是发生扔鸡蛋行为后的状态所需的扔鸡蛋次数
                而最小操作次数怎么算?很显然就是在i楼之下分别扔一次然后取最少的操作数来确定这个k出自哪里
                因为这个k取值范围内的都是合格的范围,所以要找出最少的操作数必然要在[1,i]内进行比较
                说白了:max比较出k层碎与不碎的最坏情形;min负责找出[1,i]这么多最坏情形决策行为的最小操作数
        3.初始化:从转移方程来看的话,i=0,1与j=0,1需要初始化
        4.遍历顺序:显然是正序遍历
        5.返回形式:直接返回dp[n][k]就是所求
        时间复杂度:O(nklogn),空间复杂度:O(nk)
        */
    int[][] dp = new int[n + 1][k + 1];
    // 初始化
    // 要与原来的dp比较求小的值,必定要初始化为最大值才不会对第一个值大的比较产生影响
    for(int i = 0; i <= n; i++) {
        Arrays.fill(dp[i], Integer.MAX_VALUE);
    }
    // 初始化i=0,1与j=0,1
    // j=0时,鸡蛋数目为0:操作数怎样都是0(无法操作)
    // j=1时,鸡蛋数目为1:当楼层数n>=1时候为n
    for(int i = 1; i <= n; i++) {
        dp[i][0] = 0;
        dp[i][1] = i;
    }
    dp[0][1] = 0;
    // i=0时,楼层数目为0:操作数怎样都是0(无法上楼)
    for(int j = 0; j <= k; j++) {
        dp[0][j] = 0;
    }
    // i=1时,楼层数目为1:当鸡蛋数k>=1时候为1,只需要扔一次即可
    for(int j = 1; j <= k; j++) {
        dp[1][j] = 1;
    }
    // 之后遍历范围为i∈[2,n],j∈[2,k]
    for(int i = 2; i <= n; i++) {
        for(int j = 2; j <= k; j++) {
            // 通过二分法在区间[1,i]确定一个最优值
            int left = 1, right = i;
            // 这里用二分查找k∈[1,i]中最小的那个dp(k)->一个v形函数
            // 最低点在中间,可以通过二分在O(logn)时间复杂度内找到最小的k值
            while(left < right) {
                // 这里的mid是偏右的,因此右边主动-1往左收缩
                int mid = left + (right - left + 1) / 2;
                // 碎了，就需要往低层继续扔：层数少 1 ，鸡蛋也少 1
                // 不碎，就需要往高层继续扔：层数是当前层到最高层的距离差，鸡蛋数量不少
                // 两种情况都做了一次尝试，所以加 1
                int breakConut = dp[mid - 1][j - 1];    // 递增
                int notBreakCount = dp[i - mid][j];     // 递减
                // 排除法（减治思想）写对二分见第 35 题，先想什么时候不是解
                // 严格大于的时候一定不是解，此时 mid 一定不是解
                // 下一轮搜索区间是 [left, mid - 1]
                if(breakConut > notBreakCount) {
                    right = mid - 1;
                }else {
                    // 这个区间一定是上一个区间的反面，即 [mid, right]
                    left = mid;
                }
            }
            // left == right时退出循环,这个下标就是最优的 k
            // 把它代入转移方程 Math.max(dp[k - 1][j - 1], dp[i - k][j]) + 1) 即可
            dp[i][j] = Math.max(dp[left - 1][j - 1], dp[i - left][j] + 1);
        }
    }
    return dp[n][k];
}
}
