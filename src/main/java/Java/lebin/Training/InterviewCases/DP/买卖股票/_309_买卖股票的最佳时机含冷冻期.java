package Java.lebin.Training.InterviewCases.DP.买卖股票;

/**
 #309.最佳买卖股票时机含冷冻期
 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 */
//时间复杂度：O(n)
//空间复杂度：O(n)
/*
1. dp定义
	dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。
	状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）  编码 0
	不持有股票状态，这里就有两种卖出股票状态
	状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）编码 1
	状态三：今天卖出股票   编码 2
	状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！编码 3

2. 递推公式
	1） 达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：
	操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]
	操作二：今天买入了，有两种情况
	前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]
	前一天是保持卖出股票的状态（状态二），dp[i - 1][1] - prices[i]
	那么dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);

	2）达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：
	操作一：前一天就是状态二
	操作二：前一天是冷冻期（状态四）
	dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);

	3）达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：
	昨天一定是持有股票状态（状态一），今天卖出
	即：dp[i][2] = dp[i - 1][0] + prices[i];

	4) 达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：
	昨天卖出了股票（状态三） dp[i][3] = dp[i - 1][2];

	综上分析，递推代码如下：
	dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
	dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
	dp[i][2] = dp[i - 1][0] + prices[i];
	dp[i][3] = dp[i - 1][2];
3. 初始化
	这里主要讨论一下第0天如何初始化。
	如果是持有股票状态（状态一）那么：dp[0][0] = -prices[0]，一定是当天买入股票。
	保持卖出股票状态（状态二），这里其实从 「状态二」的定义来说 ，很难明确应该初始多少，这种情况我们就看递推公式需要我们给他初始成什么数值。
	如果i为1，第1天买入股票，那么递归公式中需要计算 dp[i - 1][1] - prices[i] ，即 dp[0][1] - prices[1]，那么大家感受一下 dp[0][1] （即第0天的状态二）应该初始成多少，只能初始为0。想一想如果初始为其他数值，是我们第1天买入股票后 手里还剩的现金数量是不是就不对了。
	今天卖出了股票（状态三），同上分析，dp[0][2]初始化为0，dp[0][3]也初始为0。
4. 遍历顺序
	从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。
*/
//时间复杂度：O(n)
//空间复杂度：O(n)
public class _309_买卖股票的最佳时机含冷冻期 {
	public int maxProfit(int[] prices) {
		int n = prices.length;
		if (n == 0) return 0;
		int[][] dp = new int[n][5];

		dp[0][0] -= prices[0]; // 持股票
		for (int i = 1; i < n; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
			dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
			dp[i][2] = dp[i - 1][0] + prices[i];
			dp[i][3] = dp[i - 1][2];
		}
		return Math.max(dp[n - 1][3], Math.max(dp[n - 1][1], dp[n - 1][2]));
	}
}


