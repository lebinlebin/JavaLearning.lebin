package Java.lebin.Training.InterviewCases.binarySearch;

import java.util.Arrays;

/*
给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。
h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）至少 有 h 篇论文分别被引用了至少 h 次。
请你设计并实现对数时间复杂度的算法解决此问题。
示例 1：
输入：citations = [0,1,3,5,6]
输出：3
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
     由于研究者有3篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3 。
 */
//理解题意
// 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。
//N 篇论文中总共有 h 篇论文分别被引用了至少 h 次；
//其余的 N - h 篇论文每篇被引用次数不超过 h 次。
/*
重要的事情说 3 遍!!!!
h 指数是 论文数量，不是引用次数。
h 指数是 论文数量，不是引用次数。
h 指数是 论文数量，不是引用次数。
可以把一个研究者的论文被引用的次数 按照升序排序（这一点是题目给出的前提，很重要）。题目其实要我们找的是一条分割线，这条分割线的含义是：分割线右边的所有论文的引用次数都很高。
所以分割线满足的条件是：分割线右边的最少引用次数 >= 分割线右边的论文篇数。题目要求返回的是论文数量。
 */
/*
分割线右边的最少引用次数 >= 分割线右边的论文篇数。
二分查找就是在区间 [left..right] 任意猜测一个位置 mid，看看下一轮应该往左边找还是往右边找。
题目要找的是「分割线右边的最少引用次数 >= 分割线右边的论文篇数」，可以对这个条件取反，写 if 和 else 语句不容易出错（详细叙述可以参考 题解）。
情况 1：如果 「分割线右边的最少引用次数 < 分割线右边的论文篇数」，这一点可以看示例 [0,| 1, 3, 5, 6]，猜测有 4 篇论文最少引用次数为 4 ，但是分割线右边的最小引用次数才为 1，说明分割线太靠左了。下一轮应该往右边找，因此下一轮搜索区间为 [mid + 1..right] ，此时设置 left = mid + 1。
情况 2：剩下的部分就是「分割线右边的最少引用次数 >= 分割线右边的论文篇数」，它肯定在区间 [left..mid] 里，此时设置 right = mid。
 */
public class _275_H指数2 {
    public int hIndex(int[] citations) {
        int len = citations.length;
//        Arrays.sort(citations);//因为已经排好序了所以这里不用排序了

        // 特殊判断
        if (citations[len - 1] == 0) {
            return 0;
        }
        // 二分查找猜测论文的数量，需要满足：分割线右边的最少引用次数 >= 分割线右边的论文篇数
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            // citations[mid] 表示分割线右边的文章的最少引用的次数
            if (citations[mid] < len - mid) {
                // 下一轮搜索区间 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索区间 [left..mid]
                right = mid;
            }
        }
        return len - left;
    }
}
